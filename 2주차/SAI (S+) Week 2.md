## 벡터
벡터: 숫자를 원소로 가지는 리스트/배열
곱하기:
- 성분곱 (Hadamard Product)

벡터의 노름(norm) 
노름 기호는 ||x||.
$L_{1}$-노름 ==> 각 성분의 크기에 따라 생기는 총 변위의 합. ==> 각 성분의 절대값을 모두 더해 구한다. 2차원에서의 벡터 v=(1,2) 인 경우, x 만큼 1, y 만큼 2가 움직였기때문에 총 변위의 값은 3.
$L_{2}$-노름 ==> 백터의 길이

$L_{1}$, $L_{2}$ 노름의 기하학적인 성질의 차이가 있기에 상황에 따라 알맞는 것을 씀!
![[노름기하학차이.png]]

코싸인 법칙 + $L_{2}$-노름을 통해 두 백터 사이의 각도를 구할 수 있! (N차원에서도 적용가능! 2차원에서만 먹히는 것x)
$$
cos = \frac{A\cdot B}{||A||_{2}\cdot ||B||_{2}}
$$
내적은? ==> 정사영 된 x의 길이를 벡터 y 길이 ||y|| 만큼 조정한 값이다.
![[내적과 정사영.png]]
==> 두 벡터의 유사도를 측정할 때 내적을 씀.
## 행열
- numpy는 행열에서 행(행벡터\==데이터)이 기본단위이다.
행벡터 모이면 행렬
$$
\begin{bmatrix}1&9&-13\\20&5&-6\\\end{bmatrix}
$$
행이 2개인 행렬.
- 벡터공간에서 사용되는 연산자의 모음으로도 볼 수 있다.
$$
\begin{bmatrix}1&2\\3&2\\\end{bmatrix}\begin{bmatrix}x\\y\\\end{bmatrix} = \begin{bmatrix}x + 2y\\3x+2y\\\end{bmatrix}
$$
- 행렬곱은 다른 차원의 공간으로의 이동으로 볼 수 있다. ==> 패턴추출과 데이터 압축 가능

### 표기
행,열 순서로 말함. 행열의 원소 $x_{ij}$ 인 경우, i번째 행 j번째 열에 있는 원소이다.

전치행열: $A^{T}$.
$x_{ij}$ 에 $x_{ji}$를 넣어 만든다.

벡터에 쓰이면 ==> 행벡터는 열벡터, 열벡터는 행벡터.

덧셈, 뺄셈 성분곱, 스칼라곱 벡터처럼 하면 됨!
## 행열곱셈
$XY = [\sum x_{ik}y_{kj}$]

numpy의 inner 함수는 A의 i번째 행벡터와 B의 j번째 행벡터의 내적을 계산하므로 수학적의 행열곱과 조금 다르다!

## 역행렬
$AA^{-1}=A^{-1}A=I$
- 행렬식이 0 아니면 역행렬 구할 수 있음.
- 행렬의 행과 열의 숫자가 같아야함.
역행렬이 없으면 유사역행렬/무어-펜로즈 역행렬 $A^{+}$ 이용.

## 행렬의 응용
- 연립방정식 풀기
- 성형회귀분
# Numpy

### 함수
numpy.array(행렬 비스무리하게 (리스트, 튜플 등등 행렬 비슷하게만 만들기))
- <class 'numpy.ndarray'> 인 행렬 반환
numpy.zeros(shape)
- 인자는 numpy.ndarray의 어트리뷰트에 해당하는 shape와 똑같은 것을 넣으면 됨
- 0으로 가득 채워진 numpy.ndarray 인 행렬 반환 (shape은 인자로 받은 것과 똑같아짐)
numpy.ones(shape)
- numpy.zeros와 똑같지만 0 대신 1 채워넣음
numpy.full(shape, 값)
- numpy.zeros, numpy.ones의 커스텀 버젼. 똑같이 지정 된 shape의 numpy.ndarray 반환 하지만 인자로 받은 값으로 체움.
numpy.eye(N, M=N, k=0)
- k 부터 시작되는 대각선은 1로 채워지고 나머지는 0으로 채워지는 N x M 행렬 반환
numpy.zeros_like(ndarray) / ones_like(ndarray) / full_like(ndarray, 값)
- 인자로 넘겨진 ndarray와 똑같은 행렬 만듬 but 행렬의 모든 원소는 각각 0,1, 값 으로 저장 
numpy.arange(n,m,steps)
- 파이썬의 기본함수 range()와 똑같음 but 차이점 몇개 있다.
	-  반환하는 것은 ndarray 형태임 (행벡터 하나 반환함).
	-  조건만 맞으면 m도 출력 됨.
numpy.random.normal(평균, 표준편차, N):
- N이 숫자인 경우, 인자로 입력받은 평균과 표준편차를 갖는 정규분포에서 N개 랜덤으로 뽑음. ndarray 반환
- N이 shape인경우, 인자로 입력받은 평균과 표준편차를 갖는 정규분포에서 랜덤으로 뽑은 숫자로 원소를 갖는 shape에 맞춘 ndarray 반환
numpy.random.rand(N) / randn(N)
- 0~1(rand()), -1~1(randn())에서 랜덤으로 N개의 수를 뽑아서 줌. ndarray 반환
numpy.random.randint(low=0, high, size=1)

numpy.random.seed(N):
- 이걸 통해 랜덤통제 가능

### 클래스 
numpy.ndarray
- 알아야 할 것
	- 모든 원소는 같은 데이터타입으로 저장됨! 만일 다양한 종류의 데이터가 array() 함수에 같이 입력되면  최대한 적절히 하나로 통일 ex([1,2,"3"] ==> 모두 문자열로 저장됨)+ 만일 안되면 error (error 유발 예시 ["문제", 1, 2] ==> error)
	- 인덱싱: $arr[0][2]\dots[2]$ , 또는 $arr[0, 2, \dots 2]$ 가능. 둘 다 똑같음.
	- Fancy Indexing --> arr\[\] 이 브래켓 안에 필요한 인덱스의 리스트를 넣어 원하는 원소를 엑세스 하는 것. ex) $arr[[0,2,3]]$ arr에 있는 인덱스 0,2,3에 해당하는 원소 엑세스 가능. $arr[[0,2,3], 2]$ 이렇게 몇 차원에 쓰던지 상관 x
	- 불리언 인덱싱
	- 사칙연산 +,-,\*,/ 다 가능 BUT arr1 과 arr2 의 원소끼리의 사칙연산을 표현한 것이지 \* 는 행렬곱이 아님! (// % 역시 포함) 
	- 행렬곱은 numpy.dot(arr1, arr2)사용
	- arr1, arr2 둘을 비교할 때에는 (\==, <, > 등등) 각 원소를 비교하고 비교의 결과(불리안)를 저장한 똑같은 ndarray를 반환함.
	- 진짜 같은지 다른지 확인하려면 논리연산자보단  numpy.array_equal(arr1, arr2)로 확인하자. 이 함수는 인자의 두 행렬이 같으면 True 다르면 False다
- 어트리뷰트
	- shape: 튜플, 각 차원 당 원소가 몇 개인지 알려줌. ex) sh = arr.shape 이 (2,3) 인 경우, sh의 길이(len(sh))는 2 이므로 2차원, 첫번째 차원은 원소 2개(행이 2개), 3번째 차원에는 원소 3개(각 행의 원소가 3개) 
	- ndim: 정수, 몇 차원인지 알려
	- size: 정수, 총 원소의 갯수를 알려줌
	- dtype ==> numpy.array() 함수의 인자로 직접 정의 할 수 있음. dtype에 저장된 데이터타입으로 ndarray 내 모든 원소가 저장됨. 만일 dtype=np.float 이면 ndarray를 만들때 저장되는 모든 원소는 np.float으로 저장됨. 만일 아무것도 선언 안되면 자동으로 적절히 저장
	- 
- 메소드
	- astype(데이터타입): ndarray의 원소가 페러메터로 들어간 데이터타입으로 바뀜. dtype도 같은 데이터타입으로 바


